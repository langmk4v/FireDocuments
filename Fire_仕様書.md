# Fire 言語仕様書

**リファレンス実装のための詳細かつ具体的な仕様書**

2026 ringo.

> **目次**
>   - [A. 字句解析 (Lexer)]()
>       - [1. 数値リテラル]()
>       - [2. 文字・文字列リテラル]()
>       - [3. 名前 (識別子)]()
>       - [4. 演算子]()
>       - [5. 記号]()
>   - [B. 構文解析 (Parser)]()
>       - [1. 型名]()
>           - [型名を使用可能な場所](#型を記述できる箇所の一覧:)
>           - [式中での型名の使用](#式中に型名が含まれる場合)
>       - [2. 式]()
>           - [演算子の優先順位]()
>           - [factor: リテラル・シンボル]()
>           - [primary: 関数呼び出し・配列添字・メンバアクセス]()
>           - [unary: 単項算術演算]()
>           - [terms: 二項算術演算]()
>           - [shift: シフト演算]()
>           - [compare: 比較]()
>           - [equality: 等価比較]()
>           - [bit: ビット演算]()
>           - [log: ブール型比較]()
>           - [assign: 代入]()
>           - [expr: 式]()
>       - [3. 文]()
>           - [条件文]()
>               - [if]()
>               - [match]()
>               - [switch]()
>           - [繰り返し文]()
>               - [for]()
>               - [loop]()
>               - [do-while]()
>               - [while]()
>           - [単文]()
>               - [return]()
>               - [break]()
>               - [continue]()
>           - [変数定義 (var)]()
>           - [例外処理 (try-catch)]() 
>           - [式文]()
>           - [スコープ]()
>       - [4. 関数]()
>       - [5. 列挙型]()
>       - [6. クラス]()
>       - [7. 名前空間]()
>   - [C. 型システム (TypeInfo)]()
>       - [1. ]()
>   - [D. 意味解析 (Sema)]()
>       - [1. スコープ構築](#1-スコープ情報の構築)
>       - [2. シンボル収集]()
>       - [3. 名前解決]()
>       - [4. 整合性・型チェック]()
>   - [E. 構文木の評価 (EvalNode)]()
>       - [1. スタック]()
>       - [2. 式の評価]()
>       - [3. 文の実行]()
>   - [F. コンパイル (LLVM-IR)]()
>       - Feature...
>   - [G. アプリケーション (Driver)]()
>       - [1. ソースファイル管理]()
>           - [ファイル読み取り]()
>           - [外部モジュール取り込み (import)]()
>       - [2. コマンドライン引数]()
>   - [H. コマンドライン実行 (REPL)]()




------------

# A. 字句解析

## 1. 数値リテラル
```
INTEGER     :=  [0-9]+
FLOAT       :=  [0-9]+\.?[0-9]*f?
```
## 2. 文字・文字列リテラル
```
CHAR        :=  '(.|\\[a-z|A-Z])'
STRING      :=  "(.|\\[a-z|A-Z])*"
```
## 3. 識別子
```
IDENTIFIER  :=  (_|[a-z]|[A-Z])([a-z]|[A-Z]|[0-9])*
```
## 4. 演算子
```
SCOPE_RESOL     ::

ADD             +
SUB             -
MUL             *
DIV             /
MOD             %

LSHIFT          <<
RSHIFT          >>

BIT_AND         &
BIT_OR          |
BIT_XOR         ^

INCLEMENT       ++
DECLEMENT       --

ASSIGN          =
ASSIGN_ADD      +=
ASSIGN_SUB      -=
ASSIGN_MUL      *=
ASSIGN_DIV      /=
ASSIGN_MOD      %=
ASSIGN_AND      &=
ASSIGN_OR       |=
ASSIGN_XOR      ^=
ASSIGN_LSHIFT   <<=
ASSIGN_RSHIFT   >>=
```
## 5. 記号
```
RIGHT_ARROW     ->
DOT             .
COMMA           ,
COLON           :
SEMICOLON       ;
EXCLAMATION     !
QUESTION        ?

HASH            #
DOLLER          $
BACKTICK        `
TILDE           ~

BRACKET_OPEN    (
BRACKET_CLOSE   )
SCOPE_OPEN      {
SCOPE_CLOSE     }
ANGLE_OPEN      <
ANGLE_CLOSE     >
ARRAY_OPEN      [
ARRAY_CLOSE     ]
```

------------

# B. 構文解析

## 1. 型名
Fire 言語では、文とそれより上層の段階 ( 以下 `A` ) では、型名を記述できる場所は完全に決められている。
そこに到達したときに限り、型名のパーサを呼び出す。

### 型を記述できる箇所の一覧:
"`A`" に該当する構文内に含まれる、全ての「型名を記述できる場所」を以下のように定義する。
>
>
>

### 式中に型名が含まれる場合
Fire では曖昧な構文木の作成を禁止する。

式中に型名が含まれている場合は、
シンボルと型名のどちらに当てはまるのかという検査や走査はしない。
はじめに、[シンボル ( `ND_` ) ](#) として

---

## 2. 式

### 演算子の優先順位

優先度 1
| 演算子 | 名称               | 結合 |
|--------|--------------------|------|
| `::`   | スコープ解決演算子 | 左   |

優先度 1
| 演算子 | 名称               | 結合 |
|--------|--------------------|------|
| `()`   | 関数呼び出し       | 左   |
| `[]`   | 配列インデックス   | 左   |


### 終端

#### リテラル

#### シンボル
> Syntax:
> ```
> symbol   :=   IDENT 
> ```

### プライマリ
### 単項算術
### 二項算術
### シフト演算
### 比較
### 等価比較
### ビット演算

---

## 3. 文

### 条件文
- `if`
```
if ::=
    "if" <cond: expr>
    <then-code: scope>
    ("else" (<if> | <scope>))?
```

### 繰り返し文
- `loop`
```
```
- `for`
```
```
- `foreach`
```
```
- `while`
```
```
- `do-while`
```
```

### 単文

- `return`
- `break`
- `continue`

### 変数定義 (`var`)
現在のスコープに変数を定義する。
すでに定義済みの場合は、シャドウイングをする。
> Syntax:
>   `var` `:=` `"var"` `IDENT` `(` `COLON` [`type-name`]() `)?` (ASSIGN expr
>
> Example:
> ```
> var a = 10;
> 
> ```

### 例外処理 (`try` `catch`)
```
try-catch   ::=
    <try-scope>
    <catch-scope> +
    <finally-scope>

try-scope   ::=
    "try" <scope>

catch-scope   ::=
    "catch" 
```

## 4. 関数

------------

# C. 型システム

TODO

------------

# D. 意味解析

各フェーズごとに分けてプログラムの意味解析を行う。
構文木を探索して処理することは全てのフェーズに共通する。

## 1. スコープ情報の構築
Node を探索し、スコープを持つ Node を元に スコープ情報 (=SI) を構築する。
すべての S は、シンボルテーブル(=SymTBL) を保持する。
また、その S に名前がある場合、S の中にシンボル情報(=SYM) をもたせる。
```cpp
struct ScopeInfo {

}
```

## 2. シンボル収集
シンボルの定義情報を収集してシンボルテーブルを作成する。

## 3. 名前解決


## 4. 整合性・型チェック

------------

# E. 構文木の評価

------------

# F. コンパイル: LLVM-IR を生成

------------

# G. アプリケーション

------------

# H. REPL
